#include <iostream>
#include <thread>
#include <mutex>
#include <atomic>
#include <vector>
#include <string>
#include <queue>

#include <sstream> //stringstream
#include <condition_variable>
#include <future>

#include <memory>
#include <coroutine>
using namespace std;




/*  => A function is a coroutine if its definition contains any of the following:
the co_await expression — to suspend execution until resumed
the co_yield expression — to suspend execution returning a value
the co_return statement — to complete execution returning a value


Restrictions
Coroutines cannot use variadic arguments, plain return statements, or placeholder return types (auto or Concept).

Consteval functions, constexpr functions, constructors, destructors, and the main function cannot be coroutines.

Coroutine must have either of
    - co_await
    - co_yield
    - co_return
it cannot have return statement

flags   -pthread -pcoroutine

Promise type of the Coroutine
    - Promise type is an object i.e struct or class
    - must  have the name prmise_type
    - nested within the return type ( here ReturnObject ) of the coroutine.
        struct ReturnObject {
            struct promise_type {
                // to do
            };
        };
    promise type doesn't have any rlation to std::promise

*/

struct ReturnObject {
    struct promise_type {
        promise_type() = default; /* Implicitly generated by compiler */

        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }
        ReturnObject get_return_object() { return {}; }
        void unhandled_exception() {}
    };
    ReturnObject() = default; /* Implicitly generated by compiler */
};
/*  Method get_return_object: constructes ReturnObject of coroutine
        - returns the parent object of promise_type 
        - Same as return type of the coroutine
        ReturnObject get_return_object() { return {}; } her  {} represent default constructed ReturnObject

        promise_type() = default;
    A default constructor for promise_type and ReturnObject
    -   In simple cases, compiler gnerates one for user

    std::suspend_never initial_suspend() { return {}; }
        - This executed just before a core routtine starts it's execution

    void unhandled_exception() {} which for simple cases can be empty
    Used for handling uncaught exceptions in the coroutine
*/

ReturnObject foo() {
    cout << "1. hello from coroutine\n";
    // co_await std::suspend_always{};
    co_await std::suspend_never{};
    cout << "2. hello from coroutine\n";
}
void T() {
    ReturnObject retObj = foo();
}

struct ReturnObject2 {
    struct promise_type {
        // promise_type() = default; /* Implicitly generated by compiler */

        std::suspend_never initial_suspend() { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }

        ReturnObject2 get_return_object() {
            return ReturnObject2{
                std::coroutine_handle<promise_type>::from_promise(*this)
            };
        }
        void unhandled_exception() {}
    };
    // ReturnObject2() = default; /* Implicitly generated by compiler */

    std::coroutine_handle<> handle;
    ReturnObject2(std::coroutine_handle<> handle_) : handle{handle_} {}
};

ReturnObject2 foo2() {
    cout << "1. hello from coroutine\n";
    co_await std::suspend_always{};
    // co_await std::suspend_never{};
    cout << "2. hello from coroutine\n";

    co_await std::suspend_always{};
    cout << "3. hello from coroutine\n";
}
void T2() {
    ReturnObject2 retObj2 = foo2();
    retObj2.handle.resume();
    retObj2.handle.resume();
    // retObj2.handle.resume();
    // retObj2.handle(); // Calls std::coroutine_handle<>::operator();

    // retObj2.handle();
    cout << std::boolalpha << retObj2.handle.done() << "\n";
}
// void T2() {
//     ReturnObject2 retObj2 = foo2();
//     while (!retObj2.handle.done()) {
//         retObj2.handle.resume();
//     }

//     cout << std::boolalpha << retObj2.handle.done() << "\n";  // true
// }






// 1.   Cannot use variadic arguments
// ReturnObject2 foo3(...) { co_await std::suspend_never(); }
ReturnObject2 foo3(auto ...args) { co_await std::suspend_never(); }

// 2.   Cannot be constexper or consteval
// constexper ReturnObject2 coro_with_constexpr() { co_await std::suspend_never{}; }

// 3.   Cannot have auto or decltype(auto) return type
auto foo4() ->ReturnObject2 { co_await std::suspend_never(); }  // Trailing Return Type
// auto with trailing return type is valid

// 4.   Cannot be constructors or destructors
struct Bar
{
    // Bar() { co_yield 5; }
    // ~Bar() { co_return std::suspend_never{}; }
};

// Cannot have plain return statement
// Use co_return to mark the end of execution


/*  Coroutine can be
A free standing coroutine
A member function of a class
A virtual function in polymorphic class
A lambda expression
A static coroutine
    Free standing
    Static member of a class
*/
// auto lambda_coro = []


// Corroutine With co_yield
struct ReturnObject3 {
    struct promise_type {
        int val_;
        std::suspend_always yield_value(int val) {
            this->val_ = val;
            return std::suspend_always{};
        }

        ReturnObject3 get_return_object() {
            return { std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() {}
    };

    std::coroutine_handle<promise_type> h_;
    ReturnObject3(std::coroutine_handle<promise_type> h) : h_{h} { }
    operator std::coroutine_handle<promise_type>() const { return h_; }

    // Helper function to get the val_ memver within promise object
    int get_value() const { return h_.promise().val_; }
};
// co_yield 5; will call promise_type::yield_value(5);
// This value could be saved in promise object and retrive it
// frome coroutine_handle

ReturnObject3 generator(int start, int end, int steps = 1) {
    for (int val{start}; val<end; val += steps) {
        co_yield val;
    }
}
void T3() {
    auto gen = generator(0, 10);

    int i{0};
    while(!gen.h_.done()) {
        cout << i++ << ".value: " << gen.get_value() << "\n";
        gen.h_();
    }
}

int main() {
    T2();
// main function Cannot be a coroutine
    T3();
}